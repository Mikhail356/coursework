# Технологии построения децентрализованных Web-систем

В этом разделе будут описаны более подробно технологии которые используются в проекте, а также те, которые служили примерами и недостатки которых пытается исправить данная работа. Технологии представлены в порядке появления терминов в предыдущем разделе.
## Webmention

Webmention (веб-упоминание) [@wm] это веб-стандарт для упоминаний и коммуникации в сети. Он является транспортом для разнообразных взаимодействий в децентрализованных социальных сетях ("комментариев", "лайков", "репостов" и других).
### Общий алгоритм работы

Веб-упоминания отправляются "от" исходного адреса URL ресурса "к" целевому адресу URL ресурса, чтобы уведомить цель о том, что она была упомянута в исходном адресе URL ресурса по следующему обобщенному алгоритму:

1. Пользователь Миша публикует запись $P_m$ в своем сетевом дневнике.
2. Пользователь Женя публикует запись $P_j$ в своем сетевом дневнике, которая ссылается на запись Миши.
3. После того, как у записи $P_j$ появляется адрес URL, сервер Миши $S_m$ помечает упоминание записи Жени $W_j$, как часть процесса публикации.
4. Сервер Миши $S_m$ загружает документ по URL записи Жени $U_j$, чтобы найти конечную точку своего упоминания _Webmention_ $W_m$ (если она не найдена, процесс останавливается).
5. Сервер Миши $S_m$ отправляет уведомление _Webmention_ на конечную точку упоминания _Webmention_ публикации Жени $W_j$ следующим образом:
    * __источник (source)__ назначается на постоянную ссылку записи Миши $P_m$
    * __цель (target)__ назначается на постоянную ссылку записи Жени $P_j$.
6. Webmention-сервис, обслуживающий сервер Жени $S_j$, получает уведомление _Webmention_. (Webmention-сервис получает и фильтрует уведомление для сервера.)
7. Сервер Жени $S_j$ проверяет, что __target__ в упоминании _Webmention_ $W_m$ является допустимой постоянной ссылкой в его блоге (если нет, обработка останавливается).
8. Сервер Жени проверяет, что источник __source__ в упоминании _Webmention_ $W_m$ содержит (с учетом перенаправлений, предусмотренных протоколом HTTP) гиперссылку на цель __target__ (если нет, обработка останавливается).

## Протокол WebSub

Протокол WebSub[@ws] предоставляет общий механизм связи между издателями любого вида веб-контента с их подписчиками, основанный на механизме обратных веб-вызовов. Запросы на подписку повторно передаются через концентраторы, которые валидируют (проверяют соответствует ли формат запроса на подписку внутренним правилам концентратора или издателя) и верифицируют запрос (проверяют действительно ли подписчик хотел подписаться на эту тему, отправляя на адрес обратного вызова подписчика GET запрос на подтверждение подписки). В общем случае это соответственно проверка того что запросы созданы правильно и то что они созданы такими какими предполагались. Затем концентраторы распространяют новую или обновленную информацию среди подписчиков, после того как он становится доступен.

### Основные определения

1. Тема (Topic). Адрес URL ресурса HTTP (HTTPS). Единица, на изменения которой можно подписаться. Информация содержащаяся в теме это тематическая лента.
2. Концентратор (Hub). Сервер (адрес URL), реализующий обе стороны этого протокола. Любой концентратор может реализовать свои собственные политики в отношении того кто имеет право им пользоваться.
3. Издатель (Publisher). Владелец информации содержащейся в теме. Уведомляет концентратор об обновлении тематической ленты. Издатель не знает подписчиков, если таковые имеются.
4. Подписчик (Subscriber). Субъект (человек/программа), которая хочет получать уведомления об изменениях в теме. Подписчик имеет прямой доступ к сети и идентифицируется по callback URL (адресу обратного вызова).
5. Подписка (Subscription). Уникальное отношение подписчика к теме, показывающее что он должен получать обновления этой темы. Уникальным ключом подписки является неизменяемый список (кортеж) (адрес URL темы, адрес URL обратного вызова подписчика). Подписки могут (если так решит концентратор) иметь определенное время действия.
6. Адрес callback URL подписчика (Subscriber Callback URL). Адрес URL по которому подписчик желает получать запросы о распространении контента.
7. Мероприятие (Event). Событие, вызывающее обновления нескольких тем (возможно одной). Каждое происходящее событие (например «Миша опубликовал сообщение в сообществе Linux.») может затронуть несколько тем (здесь «Миша опубликовал сообщение.» и «В сообществе Linux появилось новое сообщение.»). _Мероприятия_ вызывают обновление тем. Затем концентратор просматривает все подписки на затронутые темы, ища и доставляя контент подписчикам.
8. Уведомление о распространении контента / (запрос на распространение контента) (Content Distribution Notification / (Content Distribution Request)). Полезная нагрузка, содержащая изменения темы или полностью обновленную тему. В зависимости от типа наполнения раздела дельта может быть вычислена концентратором и отправлена всем подписчикам.

### Общий принцип работы

1. Миша находит на одном из сторонних сайтов сообщение, содержащее URL адрес некоторой темы и ее краткое описание (автором которой является Женя), и желает подписаться.
2. Он отправляет POST запрос на указанный URL адрес. При этом тема может обновляться при помощи нескольких концентраторов, для поддержания отказоустойчивости протокола.
3. Женя уведомляет URL адреса концентратора(ов) об изменении темы.
4. Когда концентратор идентифицирует изменение в разделе, он отправляет уведомление о распространении контента всем зарегистрированным подписчикам (в том числе Мише).

## Язык разметки Microformats2

Microformats2[@mf2] это последняя версия микроформатов, самый простой способ разметки структурированной информации в HTML. Microformats2 упрощает авторам (издателей) написание интересного подписчикам текста, веб-разработчикам создание структуры и оформления веб-страниц и разработчикам парсеров веб-страниц извлечение нужной информации из нее для дальнейшей работы по сравнению с предыдущей версией. Главное отличие от других способов разметки файлов HTML состоит в том, что он поддерживает создание дополнительных классов.

### Префиксы для имен классов

Все имена классов микроформатов используют префиксы. Префиксы-это синтаксис, независимый от разрабатываемых отдельно словарей.
1. `h-*` для имен корневых классов (например h-card). h-card это простой открытый формат для публикации людей и организаций в сети Интернет. Обычно его используют как базовый микроформат HTML разметки в котором перечислены основные параметры о человеке/организации. Особенность корневых классов заключается в том, что они могут содержать в качестве подклассов микроформаты с любым префиксом.
2. `p-*` для свойств обычного текста (например p-name)
3. `u-*` для свойств адреса URL (например u-photo)
4. `dt-*` для свойств даты/времени (например dt-bday)
5. `e-*` для свойств встроенной разметки (например e-content, e-note). Содержит в себе форматированный HTML текст.

## Распределенная сеть the solid ecosystem

Solid[@solid] - это промежуточная итерация от одного из изобретателей всемирной паутины Джона Бернерса-Ли. Он считает, что развитие сети интернет отошло от начальной концепции. Сначала она задумывалась как децентрализованная сеть. Идея состояла в том, что каждый пользователь может просматривать, создавать и изменять документы при помощи браузера.

### Общие положения

1. На Solid сервере размещается один или несколько Solid модулей ("подов"), доступных по протоколу Solid.
2. Модуль, размещенный на Solid сервере, полностью отделен от всех остальных. Он имеет свой собственный набор данных и правил доступа и полностью контролируется пользователем, которому он принадлежит.
3. Пользователь сам решает, где разместить свой модуль. Он может выбрать либо разместить под самостоятельно, либо под размещается расширяющейся сетью поставщиков модулей-устройств вместо него.
4. Пользователь также может иметь более одного под, которые, возможно, размещены в разных местах (то есть на различных носителях информации, имеющих доступ к Solid). Это эффективно и прозрачно для приложений и служб, которые использует клиент, потому что его данные, где бы они ни были размещены, или данные, которыми он поделился, все связаны через его личность.
5. Пользователь может хранить любые данные в Solid модуле, и может определить, кто или что может получить доступ к этим данным на детальном уровне, используя системы аутентификации и авторизации Solid.
6. Хранимые пользователем данные совместимы с другими. Это возможно благодаря открытому стандарту форматов на основе RDFS [@rdfs], HTML[@html], FOAF[@foaf], LDP[@ldp], vCard[@vcard]. Они могут быть проверены Solid сервером для гарантии сохранения целостности данных после взаимодействия с ними разрозненных приложений.

Подводя итог это означает, что пользователь может делиться определенными частями данных второго пользователя с другими людьми и группами, которым доверяет второй, или с экосистемой приложений и сервисов, которые могут читать и записывать данные в пользовательском поде, используя стандартные шаблоны для взаимодействия приложений. И точно так же, как первый пользователь может поделиться своими данными с другим, так и другой пользователь может поделиться своими данными с первым.
