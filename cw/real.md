# Реализация макета децентрализованной системы
В данном разделе приводится подробное описание работы системы и набора используемых технологий. Это нужно для создания физического объекта, на котором будут проверяться математические выводы получнные на модели предыдущего раздела. Также бывает полезным для построения математических выводов явно представлять себе всю структуру реализованной системы. Перейдем к описанию основных рабочих объектов.
## Определения
1. Сервер $-$ сервер, которым владеет определенное научное учреждение.
1. Страница ученого $-$ HTML-страница содержащая информацию об ученом, его соавторах и публикациях.
2. Страница публикации $-$ HTML-страница содержащая информацию о публикации и ее авторах. Cтраницы ученых и их публикаций содержатся на сервере.
4. Источник (source) $-$ страница ученого/публикации с которой отправляют web интернет запросы.
5. Цель (target) $-$ страница ученого/публикации на которую поступают web интернет запросы.
4. WebMention-сервер $-$ специальный сервер, который получает и записывает в базу данных запросы от серверов в определенном формате: адрес URL источника (source), адрес URL цели (target), URL адрес WebMention-сервера. Отличается своей структурой от сервера, но может как быть собственностью соответствующего серверу научного учреждения, так и быть сторонним.
6. База Данных (БД) $-$ хранит записи в формате: URL адрес source источника, URL адрес target цели, время поступления запроса на WebMention-сервер, URL адрес WebMention-сервера. Является собственностью соответствующего серверу и WebMention-серверу научного учреждения.

## Команды работы с проектом
Чтобы дать физическое оформление способам связи из предыдущего раздела в проекте используется язык программирования Python3. В настоящем разделе приведено краткое описание реализации проекта. В его работе используется всего две команды: команда обновления и команда проверки информации в базе данных веб-запросов пользователя. Такой набор команд в настоящее время представляется достаточным для отработки основных сценариев взаимодействия узлов в децентрализованной системе.
### Команда обновления (update)
Начать стоит с описания поведения команды обновления. На вход ей подается URL адрес страницы. Команда отпраляет все ссылки в ней на WebMention-сервер, который записывает их в соответствующем формате в БД. Используется перед удалением страницы или после изменения содержимого страницы, не затрагивающего ссылки. Дадим более детальное с технической точки зрения описание. Алгоритм работы:
1. Отправить GET запрос на указанный в командной строке URL адрес. Результатом будет код страницы и/или ошибки.
2. Если ответ пришел без ошибок (с кодом 200), то перейти к следующему шагу. Иначе прекратить работу и вывести сообщение об ошибке.
3. Разобрать HTML код страницы, полученный на втором шаге. Выходом шага является beautifulsoup объект.
4. Найти все ссылки в HTML-документе на другие страницы и URL адрес WebMention-сервера. Входной объект это beautifulsoup полученный на предыдущем шаге. В результате выполнения получится список из картежей, состоящих из аргументов необходимых для POST запроса в следующем шаге.
5. Отправить на URL адрес WebMention-сервера POST запросы, содержащие:
    1. URL Адрес личного  WebMention-сервера для сервера, содержащего текущую страницу.
    1. URL Адрес текущей страницы.
    1. URL Адрес целевой страницы.


Примечание. После работы команды происходит вывод URL адресов обновленных страниц на экран.

### Команда проверки (check)
Приступим к формальному описанию следующей команды, а именно проверки. На вход ей подается адрес HTML-файла страницы на информационном носителе и ее URL адрес. Команда скачивает из БД свои запросы, появившиеся после последней проверки, и редактирует существующую страницу в соответствии с ними. Редактирование происходит путем добавления и удаления новых блоков с информацией об ученых, публикациях, ссылках. Используется после изменения ссылок внутри страницы. Перейдем к формальному описанию выполнения команды. Алгоритм работы:
1. Разобрать HTML-страницу на теги. На вход подается время последнего обновления страницы, нужный URL адрес, адрес файла в носителе информации.
3. Найти в разборе адрес URL WebMention-сервера.
4. Получить от WebMention-сервера все уведомления.
5. Отправить GET запрос на все WebMention-сервера с целью на страницы, запросы которых содержали целью текущую страницу.
	Для каждого ответа на GET запрос выполнить следующий цикл:
	1. Если результат запроса оказался удовлетворительным (вернулся с кодом 200) перейти к следующему пункту, иначе поместить обрабатываемую страницу в список адресов страниц на удаление (с именем remove).
	2. Провести проверку полученной GET запросом страницы на подлинность (то есть что она находится на одном из подключенных пучков и ее внутренняя HTML структура соответсвует общим правилам оформления веб-страницы), в случае успеха перейти к следующему шагу, иначе поместить данную страницу в список адресов страниц на удаление (с именем remove).
	3. URL адрес страницы поместить в список адресов страниц для добавления (с именем add).
	4. Найти в разборе текущей страницы все ссылки на другие страницы и поместить в список current.
5. Если в разборе страницы есть адреса страниц подлежащих удалению (находятся в списке remove), то сделать соответствующие виртуальные изменения в коде страницы.
6. Если в списке current нет каких-то URL адресов из списка add, то сделать соответствующие виртуальные изменения в коде страницы.
12. Вывести на экран список изменений страницы и запросить пользователя разрешение на их внесение в физический код страницы.
13. В случае отказа, завершить работу команды. Иначе провести изменения кода страницы.
15. Вызвать команду update, описанную выше.

Примечание. В реализации команды проверки на языке Python3 используется дополнительный файл, в котором хранится информация о времени последнего запуска команды для текущей страницы.

## Работа с microformats2
Для работы вышеописанных алгоритмов нужно описать как именно строится страница и какие используются имена классов в microformats2 формате. Пример разметки страницы с ее использованием дает общее представление об этом.
``` html 
<!DOCTYPE HTML>
<html>
  <head>
   <meta http-equiv="content-type" content="text/html" charset="utf-8">
   <title>Кривчиков Максим Александрович</title>
   <link rel="webmention" href="http://127.0.0.1:1234" />
  </head>
  <body>
    <div class="h-card">
      <span class="p-name">Кривчиков Максим Александрович</span>
      <p>
      <span class="p-honorific-suffix">Кандидат ф.-м. наук</span>,
      <span class="p-role">доцент кафедры вычислительной математики</span>.
      </p>
    </div>
   </body>
</html>
```
Элемент __<!DOCTYPE HTML>__ это указание что нужно данная страница написана с использованием ообщего синтаксиса HTML.

Тег __html__ свидетельствует о начале/конце HTML документа.

Тег __head__ хранит данные необходимые браузеру для работы с содержимым HTML-файла.

Тег __meta__ описывает метаданные о HTML-файле. В этом примере это информация что файл написан в виде HTML текста в кодировке utf-8.

Тег __title__ добавляет поясняющий текст к ссылке в виде всплывающей подсказки. Подсказка отображается, когда курсор мыши задерживается на ссылке.

Тег __link__ содержит URL адрес WebMention-сервера, который обслуживает эту страницу.

Тег __div__ блочный элемент, предназначенный для выделения части документа, чтобы можно было менять вид содержимого.

Класс __h-card__ служит для выделения фрагмента документа. Содержит другие классы, теги и общую информацию о сотруднике.

Тег __span__ лужит для определения строчных элементов HTML-файла.

Класс __p-name__ описывает имя человека, о котором эта страница.

Класс __p-honorific-suffix__ дает описание ученой степени сотрудника.

Класс __p-role__ содержит информацию о должности.

Тег __p__ блочный элемент, определяющий текстовый абзац.


Разбор этого HTML кода в json файле при помощи Python3 расширения mf2py будет выглядеть так.
``` json 
{
    "items": [
        {
            "type": [
                "h-card"
            ],
            "properties": {
                "name": [
                    "Кривчиков Максим Александрович"
                ],
                "honorific-suffix": [
                    "Кандидат ф.-м. наук"
                ],
                "role": [
                    "доцент кафедры вычислительной математики"
                ]
            }
        }
    ],
    "rels": {
        "webmention": [
            "http://127.0.0.1:1234"
        ]
    },
    "rel-urls": {
        "http://127.0.0.1:1234": {
            "text": "",
            "rels": [
                "webmention"
            ]
        }
    },
    "debug": {
        "description": "mf2py - microformats2 parser for python",
        "source": "https://github.com/microformats/mf2py",
        "version": "1.1.2",
        "markup parser": "html5lib"
    }
}
```
Видно что использован специальный микроформат h-card и его аргументы p-name, p-honorific-suffux, p-role для разметки информации. Примечательно, что все дочерние теги могут иметь любые имена после определенной приставки, как и описано в обзоре технологий построения распределенных веб-систем. Также в более сложных страницах для описания используются microformats2-классы h-istina-coauthors (для описания соавторов сотрудника), h-istina-article-journal (для краткого описания публикации), h-istina-authors (для перечисления авторов некоторой научной работы). 

## Запуск макета
В подтверждение реализации всех описанных выше алгоритмов и использования описанных технологий представляется опишем процесс запуска и работы с уже существующим проектом. Найти его можно в GitHub репозитории [@cw]. Для его запуска в Ubuntu нужно выполнить несколько команд:
1. Скачать и установить все необходимые python библиотеки : mf2py, mf2util, json, sys, requests, aiosqlite, sqlite3, bs4, а также версию python не ниже 3. также нужно установить darkhttpd.
2. Запустить команду start.sh (создает сервера при помощи darkhttpd), находится в папке serv.
3. Запустить при помощи команды python3 webmention-logger.py WebMention-сервер.

После этих команд запустится несколько локальных серверов которые будут раздавать документы из соответствующих им папок. Так, например, содержимое папки serv/1 будет доступно по пути http://127.0.0.1:8081/ с добавлением соответствующего названия файла.

На момент написания данной работы макет обрабатывает только 2 ситуации:
1. Пользователь обновляет ссылки определенной страницы (например serv/1/index.html) в базе данных, тогда нужно ввести команду python3 update.py http://127.0.0.1:8081/index.html. 
2. Пользователь проверяет, действительны ли еще ссылки текущей страницы (serv/1/index.html) и нужно ли их дополнить новыми. Тогда нужно ввести команду python3 check.py serv/1/index.html http://127.0.0.1:8081/index.html. В ходе работы нужно будет подтвердить или отвергнуть изменения текущей страницы.

